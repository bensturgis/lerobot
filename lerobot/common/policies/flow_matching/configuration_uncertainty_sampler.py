from dataclasses import dataclass, field
from pathlib import Path
from typing import Sequence

"""
Explanation of shared uncertainy sampler attributes:
- num_action_seq_samples: Number of candidate action sequences to sample.
- exact_divergence: Whether to compute the exact divergence or use the Hutchinson
    trace estimator when computing the log-likelihood for an action sequence sample.
- scoring_metric: Which uncertainty metric to use.
    - "likelihood": Negative log-likelihood of the action sequence.
    - "intermediate_vel_norm": average L2 norm of the velocity field over intermediate
        evaluation points of the ODE.
    - "terminal_vel_norm": average L2-norm of the velocity field evaluated only for the
        final state of the ODE at times close to t=1.0.
    - "intermediate_vel_diff": average L2 norm of the velocity differences between the
        scorer and sampler ODE over intermediate evaluation points of the ODE.
- scorer_model_path: Path to the pretrained flow matching model that serves as the “scorer”
    for ensembling methods. The scorer is the model used to compute log-likelihoods for the
    action sequences generated by the primary “sampler” flow-matching model. If None and
    cross-likelihood sampling is requested, an error will be raised.
"""

def validate_metric(field_name: str, metric: str, allowed: Sequence[str]) -> None:
    """
    Raise ValueError if metric is not one of allowed.
    """
    if metric not in allowed:
        allowed_list = ", ".join(f"'{m}'" for m in allowed)
        raise ValueError(
            f"{field_name!r} must be one of: {allowed_list}. Got {metric!r}."
        )

# Sub-configs for each uncertainty sampler.
@dataclass
class CrossLaplaceSamplerConfig:
    num_action_seq_samples: int = 1
    exact_divergence: bool = False
    # Which layer(s) to place the Laplace posterior on:
    #  - "velocity_last": The final layer of the flow matching velocity model
    #  - "rgb_last": the final layer of the RGB encoder
    #  - "both": jointly on both layers
    laplace_scope: str = "both"
    # Parameters for the Laplace approximation calibration dataloader.
    calib_fraction: float = 1.0
    batch_size: int = 32
    scoring_metric: str = "likelihood"

    def __post_init__(self):
        # Validate Laplace scope
        allowed_scopes = {"velocity_last", "rgb_last", "both"}
        if self.laplace_scope not in allowed_scopes:
            raise ValueError(
                f"CrossLaplaceSamplerConfig.laplace_scope must be one of "
                f"{sorted(allowed_scopes)}, got {self.laplace_scope!r}."
            )
        
        # Validate scoring metric
        validate_metric(
            field_name="CrossEnsembleSamplerConfig.scoring_metric",
            metric=self.scoring_metric,
            allowed=(
                "likelihood", "intermediate_vel_norm", "terminal_vel_norm", "intermediate_vel_diff",
            ),
        )

@dataclass
class ComposedCrossEnsembleSamplerConfig:
    num_action_seq_samples: int = 1
    exact_divergence: bool = False
    scorer_model_path: str | Path | None = None
    # Allowed scoring metrics: "likelihood" and "terminal_vel_norm".
    scoring_metric: str = "likelihood"

    def __post_init__(self):
        validate_metric(
            field_name="CrossEnsembleSamplerConfig.scoring_metric",
            metric=self.scoring_metric,
            allowed=(
                "likelihood", "terminal_vel_norm",
            ),
        )

@dataclass
class CrossEnsembleSamplerConfig:
    num_action_seq_samples: int = 1
    exact_divergence: bool = False
    scorer_model_path: str | Path | None = None
    scoring_metric: str = "likelihood"

    def __post_init__(self):
        validate_metric(
            field_name="CrossEnsembleSamplerConfig.scoring_metric",
            metric=self.scoring_metric,
            allowed=(
                "likelihood", "intermediate_vel_norm", "terminal_vel_norm", "intermediate_vel_diff",
            ),
        )

@dataclass
class ComposedSequenceSamplerConfig:
    num_action_seq_samples: int = 1
    exact_divergence: bool = False
    # Allowed scoring metrics: "likelihood" and "terminal_vel_norm".
    scoring_metric: str = "likelihood"
    
    def __post_init__(self):
        validate_metric(
            field_name="CrossEnsembleSamplerConfig.scoring_metric",
            metric=self.scoring_metric,
            allowed=(
                "likelihood", "terminal_vel_norm",
            ),
        )

@dataclass
class LikSamplerConfig:
    num_action_seq_samples: int = 1
    exact_divergence: bool = False

@dataclass
class EpsilonBallSamplerConfig:
    num_action_seq_samples: int = 1
    # Radius of the input noise ball.
    epsilon: float = 1e-3
    # Number of samples to draw from epsilon-ball around initial noise samples.
    num_eps_ball_samples: int = 100

@dataclass
class UncertaintySamplerConfig:
    type: str = "cross_ensemble"
    composed_cross_ensemble_sampler: ComposedCrossEnsembleSamplerConfig = field(
        default_factory=ComposedCrossEnsembleSamplerConfig
    )
    composed_sequence_sampler: ComposedSequenceSamplerConfig = field(
        default_factory=ComposedSequenceSamplerConfig
    )
    cross_ensemble_sampler: CrossEnsembleSamplerConfig = field(
        default_factory=CrossEnsembleSamplerConfig
    )
    cross_laplace_sampler: CrossLaplaceSamplerConfig = field(default=CrossLaplaceSamplerConfig)
    likelihood_sampler: LikSamplerConfig = field(default_factory=LikSamplerConfig)
    epsilon_ball_sampler: EpsilonBallSamplerConfig = field(
        default_factory=EpsilonBallSamplerConfig
    )